# unsigned_tx_prep.py
import os
from dotenv import load_dotenv
from web3 import Web3
from eth_abi import encode_abi

load_dotenv()
RPC = os.getenv("WEB3_PROVIDER")
w3 = Web3(Web3.HTTPProvider(RPC))

ROUTER = Web3.toChecksumAddress(os.getenv("ROUTER_ADDRESS"))      # e.g. Uniswap/Pancake router
WETH = Web3.toChecksumAddress(os.getenv("WRAPPED_NATIVE"))
PRIVATE_CHAIN_ID = int(os.getenv("CHAIN_ID", "1"))

# Example: build swapExactETHForTokens calldata (router ABI minimal)
ROUTER_ABI = [
    {
      "name":"swapExactETHForTokens",
      "type":"function",
      "inputs":[
        {"type":"uint256","name":"amountOutMin"},
        {"type":"address[]","name":"path"},
        {"type":"address","name":"to"},
        {"type":"uint256","name":"deadline"}
      ],
      "outputs":[{"type":"uint256[]","name":"amounts"}]
    }
]
router = w3.eth.contract(address=ROUTER, abi=ROUTER_ABI)

def build_unsigned_swap(to_address, target_token, eth_amount_wei, slippage_bps=200):
    deadline = int(w3.eth.get_block('latest').timestamp) + 300
    path = [WETH, Web3.toChecksumAddress(target_token)]
    # amountOutMin should be calculated from price oracles â€” placeholder here:
    amount_out_min = 0
    data = router.encodeABI(fn_name="swapExactETHForTokens",
                            args=[amount_out_min, path, Web3.toChecksumAddress(to_address), deadline])
    unsigned_tx = {
        "to": ROUTER,
        "value": eth_amount_wei,
        "data": data,
        "gas": 400000,        # estimate properly in prod
        "gasPrice": w3.eth.gas_price,
        "chainId": PRIVATE_CHAIN_ID,
        # "nonce": ... DO NOT set nonce if this is a multisig proposal
    }
    return unsigned_tx

# Example usage
if __name__ == "__main__":
    tx = build_unsigned_swap("0xYourSafeAddress", "0xNewTokenAddress", eth_amount_wei=Web3.toWei(0.1,'ether'))
    print("Unsigned tx payload:", tx)
